"""CLI interface for focusgroup."""

import asyncio
import subprocess
from pathlib import Path
from typing import Annotated

import typer
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.table import Table

from focusgroup import __version__
from focusgroup.config import (
    AgentConfig,
    AgentProvider,
    FocusgroupConfig,
    OutputConfig,
    QuestionsConfig,
    SessionConfig,
    ToolConfig,
    get_agents_dir,
    get_preset_path,
    list_agent_presets,
    load_agent_preset,
    load_config,
)
from focusgroup.modes.orchestrator import SessionOrchestrator
from focusgroup.output import format_session, get_formatter
from focusgroup.storage.session_log import SessionStorage, get_default_storage
from focusgroup.tools.cli import create_cli_tool

MAIN_EPILOG = """
[bold]Providers:[/bold]

  [cyan]claude[/cyan] - Uses Claude CLI. Requires: claude CLI installed.
  [cyan]codex[/cyan]  - Uses Codex CLI. Requires: codex CLI installed.

  Both providers support exploration and synthesis modes.

[bold]Modes:[/bold]

  [cyan]--explore[/cyan] (-e)      Let agents run the tool interactively
  [cyan]--synthesize-with[/cyan]   Add a moderator to synthesize responses

[bold]Exploration Mode (--explore):[/bold]

  [yellow]⚠ SECURITY WARNING[/yellow]: Agents run with relaxed sandbox protections.
  See docs/exploration.md for full security details.

  What agents can do:
  - Run the target tool with any arguments
  - Execute arbitrary shell commands
  - Read/write files and access network

  Working directory: Inherits from focusgroup process
  Timeout: 300s (vs 120s default), configurable via --timeout
  Recommendation: Use in containers/VMs for untrusted tools

  Best for: Interactive testing, workflow validation, edge case discovery

[bold]Quick Start:[/bold]

  focusgroup ask "Is the help clear?" -x "mytool --help"
  focusgroup init                  # Create a config file
  focusgroup doctor                # Verify setup
"""

app = typer.Typer(
    name="focusgroup",
    help="Gather feedback from multiple LLM agents on tools designed for agent use.",
    no_args_is_help=True,
    epilog=MAIN_EPILOG,
)

AGENTS_HELP = """Manage agent presets.

Presets are TOML files that configure agents for focusgroup sessions.
Each preset defines a provider, optional model, and system prompt.

[bold]Preset Locations:[/bold]
  Built-in:  shipped with focusgroup (claude-default, ux-reviewer, etc.)
  User:      ~/.config/focusgroup/agents/*.toml (override built-in)

[bold]Quick Start:[/bold]
  focusgroup agents init my-reviewer     # Create template
  focusgroup agents show my-reviewer     # View configuration
  focusgroup agents list                 # See all presets
"""

agents_app = typer.Typer(help=AGENTS_HELP, rich_markup_mode="rich")
logs_app = typer.Typer(help="View and manage session logs.")

app.add_typer(agents_app, name="agents")
app.add_typer(logs_app, name="logs")

# Plain mode flag - set by --plain/--no-rich callback
_plain_mode: bool = False

console = Console()


# --- Init command ---

INIT_EXAMPLES = """
[bold]Examples:[/bold]

  Interactive setup (recommended for first use):
  [dim]$ focusgroup init[/dim]

  Specify output file:
  [dim]$ focusgroup init -o my-session.toml[/dim]

  Non-interactive with defaults:
  [dim]$ focusgroup init --tool mytool --quick[/dim]

  Quick setup with custom tool:
  [dim]$ focusgroup init --tool mx --provider claude --quick[/dim]
"""


def _generate_config_toml(
    tool: str,
    mode: str,
    provider: str,
    num_agents: int,
    questions: list[str],
    output_format: str,
    moderator: bool,
    exploration: bool,
) -> str:
    """Generate a TOML configuration file content."""
    lines = [
        "# =============================================================================",
        f"# Focusgroup Session Config - {tool}",
        "# =============================================================================",
        "#",
        "# Generated by: focusgroup init",
        "# Edit this file to customize your feedback session.",
        "#",
        "# Run with: focusgroup run <this-file>",
        "# =============================================================================",
        "",
        "[session]",
        f'name = "{tool}-feedback"',
        f'mode = "{mode}"',
    ]

    if exploration:
        lines.append("exploration = true          # Agents can run the tool interactively")
        lines.append("# agent_timeout = 300       # Default for exploration; customize if needed")

    if moderator:
        lines.append("moderator = true            # Enable synthesis at the end")
        lines.append("")
        lines.append("[session.moderator_agent]")
        lines.append(f'provider = "{provider}"')
    else:
        lines.append("moderator = false")

    lines.extend(
        [
            "",
            "[tool]",
            f'command = "{tool}"',
            'help_args = ["--help"]     # Customize if your tool uses different args',
            "",
        ]
    )

    # Generate agents
    for i in range(num_agents):
        lines.append("[[agents]]")
        lines.append(f'provider = "{provider}"')
        if num_agents > 1:
            lines.append(f'name = "Agent-{i + 1}"')
        lines.append("")

    # Questions
    lines.append("[questions]")
    lines.append("rounds = [")
    for q in questions:
        # Escape quotes in the question
        escaped_q = q.replace('"', '\\"')
        lines.append(f'    "{escaped_q}",')
    lines.append("]")
    lines.append("")

    # Output
    lines.append("[output]")
    lines.append(f'format = "{output_format}"')
    lines.append("save_log = true")

    return "\n".join(lines) + "\n"


@app.command(epilog=INIT_EXAMPLES)
def init(
    output: Annotated[
        Path | None,
        typer.Option("--output", "-o", help="Output file path for config"),
    ] = None,
    tool: Annotated[
        str | None,
        typer.Option("--tool", "-t", help="Tool command to evaluate"),
    ] = None,
    provider: Annotated[
        str | None,
        typer.Option("--provider", "-p", help="Agent provider: claude or codex"),
    ] = None,
    quick: Annotated[
        bool,
        typer.Option("--quick", "-q", help="Use defaults, skip interactive prompts"),
    ] = False,
) -> None:
    """Initialize a new focusgroup session config file.

    Creates a TOML configuration file with prompts for tool name, questions,
    agent settings, and other options. Use --quick to skip prompts and use
    sensible defaults.
    """
    # Determine output path
    if output is None:
        default_name = f"{tool or 'session'}.toml" if tool else "focusgroup.toml"
        output = Path(default_name)

    # Check if file exists
    if output.exists() and not quick:
        overwrite = typer.confirm(f"File {output} already exists. Overwrite?")
        if not overwrite:
            console.print("[dim]Cancelled.[/dim]")
            raise typer.Exit(0)

    if quick:
        # Use defaults for quick mode
        final_tool = tool or "mytool"
        final_provider = provider or "claude"
        final_mode = "single"
        final_num_agents = 2
        final_questions = [
            "What's your first impression of this tool's interface?",
            "What improvements would make this tool easier for AI agents to use?",
        ]
        final_output_format = "text"
        final_moderator = False
        final_exploration = False
    else:
        # Interactive mode
        console.print("\n[bold]Focusgroup Session Setup[/bold]\n")

        # Tool
        final_tool = tool or typer.prompt(
            "Tool command to evaluate",
            default="mytool",
        )

        # Provider
        if provider:
            final_provider = provider
        else:
            console.print("\n[dim]Available providers: claude, codex[/dim]")
            final_provider = typer.prompt(
                "Agent provider",
                default="claude",
            )
            if final_provider not in ("claude", "codex"):
                console.print(
                    f"[yellow]Warning: '{final_provider}' is not a known provider[/yellow]"
                )

        # Mode
        console.print("\n[dim]Modes:[/dim]")
        console.print("  [cyan]single[/cyan]      - Each agent responds once, independently")
        console.print("  [cyan]discussion[/cyan]  - Agents see and respond to each other")
        console.print("  [cyan]structured[/cyan]  - Phases: explore, critique, suggest, synthesize")
        final_mode = typer.prompt(
            "Session mode",
            default="single",
        )

        # Number of agents
        final_num_agents = typer.prompt(
            "Number of agents",
            default=2,
            type=int,
        )

        # Questions
        console.print("\n[dim]Enter questions for the agents (empty line to finish):[/dim]")
        final_questions = []
        default_questions = [
            "What's your first impression of this tool's interface?",
            "What improvements would make this tool easier for AI agents to use?",
        ]

        for i, default_q in enumerate(default_questions):
            q = typer.prompt(f"Question {i + 1}", default=default_q)
            if q.strip():
                final_questions.append(q)

        # Allow more questions
        while True:
            q = typer.prompt(
                f"Question {len(final_questions) + 1} (Enter to skip)",
                default="",
            )
            if not q.strip():
                break
            final_questions.append(q)

        if not final_questions:
            final_questions = default_questions

        # Output format
        console.print("\n[dim]Output formats: text, markdown, json[/dim]")
        final_output_format = typer.prompt(
            "Output format",
            default="text",
        )

        # Moderator
        final_moderator = typer.confirm(
            "Enable moderator for synthesis?",
            default=False,
        )

        # Exploration
        console.print("\n[dim]Exploration mode lets agents run the tool directly.[/dim]")
        console.print("[dim]They can test commands, check output, and explore edge cases.[/dim]")
        console.print("[dim]Timeout increases to 300s. Runs in current directory.[/dim]")
        final_exploration = typer.confirm(
            "Enable exploration mode?",
            default=False,
        )

    # Generate config
    config_content = _generate_config_toml(
        tool=final_tool,
        mode=final_mode,
        provider=final_provider,
        num_agents=final_num_agents,
        questions=final_questions,
        output_format=final_output_format,
        moderator=final_moderator,
        exploration=final_exploration,
    )

    # Write file
    output.write_text(config_content)
    console.print(f"\n[green]✓[/green] Created config: {output}")
    console.print("\n[dim]Run your session with:[/dim]")
    console.print(f"  focusgroup run {output}")

    # Show next steps
    if not quick:
        console.print("\n[dim]Or try a quick check first:[/dim]")
        console.print(
            f'  focusgroup ask {final_tool} "Is the --help clear?" -x "{final_tool} --help"'
        )


def infer_tool_from_context(context: str) -> str:
    """Infer the tool name from a context string.

    Args:
        context: "@path/to/file" for file, "-" for stdin, or a command string

    Returns:
        Inferred tool name:
        - For commands: first token (e.g., "mx --help" -> "mx")
        - For files: filename stem (e.g., "@path/to/README.md" -> "README")
        - For stdin ("-"): "unknown"
        - Fallback: "unknown"
    """
    if not context or not context.strip():
        return "unknown"

    context = context.strip()

    if context == "-":
        # Stdin: can't infer tool name
        return "unknown"
    elif context.startswith("@"):
        # File context: use filename stem
        file_path = context[1:].strip()
        if file_path:
            return Path(file_path).stem or "unknown"
        return "unknown"
    else:
        # Command context: use first token
        tokens = context.split()
        if tokens:
            return tokens[0]
        return "unknown"


def resolve_context(context: str) -> str:
    """Resolve context from stdin, a file path, or shell command.

    Args:
        context: "-" for stdin, "@path/to/file" to read a file, or a shell command

    Returns:
        The stdin content, file contents, or command output

    Raises:
        typer.Exit: If file not found, command fails, or stdin read fails
    """
    import sys

    if context == "-":
        # Read from stdin
        try:
            return sys.stdin.read()
        except Exception as e:
            console.print(f"[red]Failed to read from stdin: {e}[/red]")
            raise typer.Exit(1) from None
    elif context.startswith("@"):
        # Read from file
        file_path = Path(context[1:]).expanduser()
        if not file_path.exists():
            console.print(f"[red]Context file not found: {file_path}[/red]")
            raise typer.Exit(1)
        try:
            return file_path.read_text()
        except Exception as e:
            console.print(f"[red]Failed to read context file: {e}[/red]")
            raise typer.Exit(1) from None
    else:
        # Run as shell command
        try:
            result = subprocess.run(
                context,
                shell=True,
                capture_output=True,
                text=True,
                timeout=30,
            )
            # Combine stdout and stderr (some tools output help to stderr)
            output = result.stdout
            if result.stderr and not output:
                output = result.stderr
            elif result.stderr:
                output = f"{output}\n{result.stderr}"

            if not output.strip():
                console.print("[yellow]Warning: Context command produced no output[/yellow]")

            return output
        except subprocess.TimeoutExpired:
            console.print("[red]Context command timed out after 30s[/red]")
            raise typer.Exit(1) from None
        except Exception as e:
            console.print(f"[red]Failed to run context command: {e}[/red]")
            raise typer.Exit(1) from None


def version_callback(value: bool) -> None:
    """Print version and exit."""
    if value:
        print(f"focusgroup {__version__}")
        raise typer.Exit()


def plain_callback(value: bool) -> None:
    """Enable plain text mode (no Rich formatting)."""
    global _plain_mode, console
    if value:
        _plain_mode = True
        # Replace global console: interprets markup but outputs plain text (no colors)
        console = Console(force_terminal=False, no_color=True, highlight=False)


@app.callback()
def main(
    version: Annotated[
        bool | None,
        typer.Option("--version", "-v", callback=version_callback, is_eager=True),
    ] = None,
    plain: Annotated[
        bool,
        typer.Option(
            "--plain",
            "--no-rich",
            callback=plain_callback,
            is_eager=True,
            help="Disable Rich formatting (for CI/piping).",
        ),
    ] = False,
) -> None:
    """Focusgroup: LLM agent feedback for tool developers."""
    pass


ASK_EXAMPLES = """
[bold]Examples:[/bold]

  Basic query (tool inferred from context):
  [dim]$ focusgroup ask "Is this help output clear?" -x "mx --help"[/dim]

  Query with file context (tool inferred as "README"):
  [dim]$ focusgroup ask "What's missing from these docs?" -x "@README.md"[/dim]

  Piped context from stdin (use --tool for labeling):
  [dim]$ cat API.md | focusgroup ask "Review this API" -x - --tool myapi[/dim]

  Explicit tool name override:
  [dim]$ focusgroup ask "Is this clear?" -x "mx --help" --tool memex[/dim]

  Exploration mode (agents can run the tool):
  [dim]$ focusgroup ask "Try common workflows" -x "mx --help" --explore[/dim]

  With synthesis from a moderator:
  [dim]$ focusgroup ask "Rate the UX" -x "mx --help" --synthesize-with claude[/dim]

  Use a different provider:
  [dim]$ focusgroup ask "Review this" -x "@docs.md" --provider codex[/dim]

  Tag sessions for organization:
  [dim]$ focusgroup ask "Review UX" -x "mx --help" --tag=release-prep[/dim]

  Combine multiple options:
  [dim]$ focusgroup ask "Full review" -x "mx --help" -e -s claude -n 5[/dim]

  Preview exploration prompt (dry run):
  [dim]$ focusgroup ask "Try workflows" -x "mx --help" --explore --dry-run[/dim]
"""


def _show_dry_run(tool: str, question: str, context: str, explore: bool) -> None:
    """Show what would be sent to agents without running them.

    Args:
        tool: Tool name
        question: The question being asked
        context: Resolved context (command output or file content)
        explore: Whether exploration mode is enabled
    """
    from focusgroup.tools.base import ToolHelp

    console.print("\n[bold cyan]═══ DRY RUN ═══[/bold cyan]")
    console.print("[dim]Showing what would be sent to agents (no API calls made)[/dim]\n")

    # Build the context that agents would see
    console.print("[bold]Tool:[/bold]", tool)
    console.print("[bold]Question:[/bold]", question)
    console.print("[bold]Exploration:[/bold]", "enabled" if explore else "disabled")

    console.print("\n[bold]─── Context Provided to Agents ───[/bold]\n")

    # Show context (truncated if very long)
    if len(context) > 2000:
        console.print(context[:1500])
        console.print(f"\n[dim]... ({len(context) - 1500} more characters truncated) ...[/dim]\n")
        console.print(context[-500:])
    else:
        console.print(context)

    # If explore mode, show the exploration instructions
    if explore:
        console.print("\n[bold]─── Exploration Instructions (appended to context) ───[/bold]\n")
        # Create a minimal ToolHelp just to get the exploration instructions
        tool_help = ToolHelp(
            tool_name=tool,
            description="",
            usage="",
            raw_output="",
        )
        exploration_text = tool_help._exploration_instructions()
        console.print(f"[dim]{exploration_text}[/dim]")

        console.print("\n[bold]─── How Exploration Works ───[/bold]")
        console.print("""
[dim]When --explore is enabled:[/dim]

1. [cyan]Shell Access[/cyan]: Agents invoke the provider CLI (claude/codex) which has
   shell command execution capabilities. Agents can run any command.

2. [cyan]Permission Model[/cyan]: Focusgroup does NOT add sandboxing. Security relies
   entirely on the provider CLI's permission model:
   - claude CLI: Prompts for dangerous operations
   - codex CLI: Has its own safety checks

3. [cyan]Working Directory[/cyan]: Agents run in YOUR current directory (inherited from
   the focusgroup process). They can read/write files here.

4. [cyan]Timeout[/cyan]: Default 300s (vs 120s normal). Customize with --timeout.

5. [cyan]What Agents Do[/cyan]: They receive the exploration instructions above,
   encouraging them to actually run the tool, try workflows, and explore edge cases.

[yellow]⚠ Caution[/yellow]: Only use --explore with tools you trust agents to invoke freely.
""")
    else:
        console.print("\n[dim]Tip: Add --explore to let agents run the tool interactively[/dim]")


@app.command(epilog=ASK_EXAMPLES)
def ask(
    question: Annotated[str, typer.Argument(help="Question to ask the agent panel")],
    context: Annotated[
        str,
        typer.Option(
            "--context",
            "-x",
            help="Context: command 'mytool --help', file '@README.md', or stdin '-'",
        ),
    ],
    tool: Annotated[
        str | None,
        typer.Option(
            "--tool",
            "-t",
            help="Tool name for session labeling (inferred from context if not provided)",
        ),
    ] = None,
    config: Annotated[
        Path | None,
        typer.Option("--config", "-c", help="Path to config file for agent settings"),
    ] = None,
    agents: Annotated[
        int,
        typer.Option("--agents", "-n", help="Number of agents to query"),
    ] = 3,
    output: Annotated[
        str,
        typer.Option("--output", "-o", help="Output format: json, markdown, or text"),
    ] = "text",
    provider: Annotated[
        str,
        typer.Option("--provider", "-p", help="Agent provider: claude or codex"),
    ] = "claude",
    explore: Annotated[
        bool,
        typer.Option(
            "--explore",
            "-e",
            help="Enable exploration mode: agents can run the tool interactively. "
            "WARNING: Bypasses sandbox protections. See docs/exploration.md for security details. "
            "Timeout increases to 300s. Agents execute in current working directory.",
        ),
    ] = False,
    synthesize_with: Annotated[
        str | None,
        typer.Option("--synthesize-with", "-s", help="Moderator agent: claude or codex"),
    ] = None,
    timeout: Annotated[
        int | None,
        typer.Option("--timeout", help="Agent timeout in seconds (default: 120, exploration: 300)"),
    ] = None,
    tag: Annotated[
        list[str] | None,
        typer.Option("--tag", help="Tag for organizing sessions (can be repeated)"),
    ] = None,
    dry_run: Annotated[
        bool,
        typer.Option(
            "--dry-run",
            help="Show what would be sent to agents without running them. "
            "Useful for previewing --explore prompts.",
        ),
    ] = False,
    yes: Annotated[
        bool,
        typer.Option(
            "--yes",
            "-y",
            help="Skip cost confirmation prompts.",
        ),
    ] = False,
    verbose: Annotated[
        bool,
        typer.Option(
            "--verbose",
            "-v",
            help="Show detailed output including agent command invocations and errors.",
        ),
    ] = False,
) -> None:
    """Quick ad-hoc query to an agent panel about a tool.

    Provide context via --context: either a shell command to run (e.g., 'mytool --help')
    or a file path prefixed with @ (e.g., '@README.md').

    The tool name is inferred from context if not explicitly provided:
    - Command context: first token (e.g., 'mx --help' → tool='mx')
    - File context: filename stem (e.g., '@README.md' → tool='README')
    """
    # Resolve context upfront (file or command)
    resolved_context = resolve_context(context)

    # Infer tool name from context if not provided
    effective_tool = tool if tool else infer_tool_from_context(context)

    # Handle dry-run: show what would be sent to agents
    if dry_run:
        _show_dry_run(effective_tool, question, resolved_context, explore)
        return

    # Cost estimation and confirmation
    from focusgroup.costs import estimate_cost, should_confirm

    estimate = estimate_cost(
        agent_count=agents,
        provider=provider,
        exploration=explore,
        synthesis=synthesize_with is not None,
    )

    if should_confirm(estimate) and not yes:
        console.print("\n[yellow]⚠ Cost Warning[/yellow]")
        console.print(f"Running {estimate.format_short()}")
        if estimate.warnings:
            for warning in estimate.warnings:
                console.print(f"  [dim]{warning}[/dim]")
        if not typer.confirm("Continue?", default=True):
            console.print("[dim]Cancelled.[/dim]")
            raise typer.Exit(0)

    asyncio.run(
        _ask_impl(
            effective_tool,
            question,
            resolved_context,
            config,
            agents,
            output,
            provider,
            explore,
            synthesize_with,
            timeout,
            tag or [],
            verbose=verbose,
        )
    )


def _parse_synthesize_with(synthesize_with: str | None) -> AgentConfig | None:
    """Parse --synthesize-with into an AgentConfig.

    Args:
        synthesize_with: String like 'codex' or 'claude'

    Returns:
        AgentConfig for the moderator, or None if not specified
    """
    if not synthesize_with:
        return None

    synthesize_with = synthesize_with.lower().strip()

    # Map string to provider
    provider_map = {
        "codex": AgentProvider.CODEX,
        "claude": AgentProvider.CLAUDE,
    }

    if synthesize_with not in provider_map:
        console.print(f"[red]Unknown synthesizer: {synthesize_with}[/red]")
        console.print("Valid options: claude, codex")
        raise typer.Exit(1)

    return AgentConfig(
        provider=provider_map[synthesize_with],
        name="Moderator",
    )


async def _ask_impl(
    tool: str,
    question: str,
    context: str,
    config_path: Path | None,
    num_agents: int,
    output_format: str,
    provider_str: str,
    explore: bool = False,
    synthesize_with: str | None = None,
    timeout: int | None = None,
    tags: list[str] | None = None,
    verbose: bool = False,
) -> None:
    """Implementation of the ask command."""
    # Parse --synthesize-with into moderator config
    moderator_config = _parse_synthesize_with(synthesize_with)
    enable_moderator = moderator_config is not None

    # If config provided, load it but override with command-line args
    if config_path:
        try:
            fg_config = load_config(config_path)
            # Override questions
            fg_config.questions = QuestionsConfig(rounds=[question])
            fg_config.output.format = output_format  # type: ignore
            # Override moderator if --synthesize-with provided
            if moderator_config:
                fg_config.session.moderator = True
                fg_config.session.moderator_agent = moderator_config
            # Override timeout if provided
            if timeout is not None:
                fg_config.session.agent_timeout = timeout
        except Exception as e:
            console.print(f"[red]Failed to load config: {e}[/red]")
            raise typer.Exit(1) from None
    else:
        # Build a quick config
        # Try built-in enum first, then custom providers
        provider_name = provider_str.lower()
        try:
            prov: AgentProvider | str = AgentProvider(provider_name)
        except ValueError:
            # Check custom providers
            from focusgroup.agents.registry import get_provider_info

            if get_provider_info(provider_name):
                prov = provider_name
            else:
                console.print(f"[red]Unknown provider: {provider_str}[/red]")
                from focusgroup.agents.registry import get_custom_providers

                custom_names = list(get_custom_providers().keys())
                if custom_names:
                    console.print(f"Valid options: claude, codex, {', '.join(custom_names)}")
                else:
                    console.print("Valid options: claude, codex")
                raise typer.Exit(1) from None

        # Create N agents with different names
        agent_configs = [
            AgentConfig(
                provider=prov,
                name=f"Agent-{i + 1}",
            )
            for i in range(num_agents)
        ]

        fg_config = FocusgroupConfig(
            session=SessionConfig(
                name=f"Quick: {tool}",
                exploration=explore,
                moderator=enable_moderator,
                moderator_agent=moderator_config,
                agent_timeout=timeout,
            ),
            tool=ToolConfig(command=tool),
            agents=agent_configs,
            questions=QuestionsConfig(rounds=[question]),
            output=OutputConfig(format=output_format, save_log=True),  # type: ignore
        )

    # Create the tool wrapper (still used for exploration mode)
    cli_tool = create_cli_tool(tool)

    # Run the session with explicit context
    orchestrator = SessionOrchestrator(
        fg_config, cli_tool, context=context, tags=tags, verbose=verbose
    )

    async def run_with_orchestrator() -> None:
        """Run orchestrator setup and session."""
        from focusgroup.agents.base import AgentError

        try:
            await orchestrator.setup()
        except AgentError as e:
            console.print(f"[red]Setup failed: {e}[/red]")
            if verbose and e.agent_name:
                console.print(f"[dim]Agent: {e.agent_name}[/dim]")
            raise typer.Exit(1) from None
        except Exception as e:
            console.print(f"[red]Setup failed: {e}[/red]")
            if verbose:
                import traceback

                console.print(f"[dim]{traceback.format_exc()}[/dim]")
            raise typer.Exit(1) from None

        try:
            async for _result in orchestrator.run_session():
                if verbose:
                    # Show per-agent timing info
                    for resp in _result.responses:
                        latency = f"{resp.latency_ms:.0f}ms" if resp.latency_ms else "N/A"
                        console.print(
                            f"[dim]  {resp.agent_name}: {len(resp.content)} chars, {latency}[/dim]"
                        )
        except AgentError as e:
            console.print(f"[red]Agent error: {e}[/red]")
            if verbose and e.agent_name:
                console.print(f"[dim]Agent: {e.agent_name}[/dim]")
            raise typer.Exit(1) from None

    if _plain_mode:
        console.print(f"Setting up with {len(fg_config.agents)} agents...")
        console.print(f"Asking about {tool}...")
        await run_with_orchestrator()
    else:
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console,
            transient=True,
        ) as progress:
            progress.add_task(f"Setting up with {len(fg_config.agents)} agents...", total=None)
            from focusgroup.agents.base import AgentError

            try:
                await orchestrator.setup()
            except AgentError as e:
                console.print(f"[red]Setup failed: {e}[/red]")
                if verbose and e.agent_name:
                    console.print(f"[dim]Agent: {e.agent_name}[/dim]")
                raise typer.Exit(1) from None
            except Exception as e:
                console.print(f"[red]Setup failed: {e}[/red]")
                if verbose:
                    import traceback

                    console.print(f"[dim]{traceback.format_exc()}[/dim]")
                raise typer.Exit(1) from None
            progress.add_task(f"Asking about {tool}...", total=None)
            try:
                async for _result in orchestrator.run_session():
                    if verbose:
                        for resp in _result.responses:
                            latency = f"{resp.latency_ms:.0f}ms" if resp.latency_ms else "N/A"
                            msg = f"  {resp.agent_name}: {len(resp.content)} chars, {latency}"
                            console.print(f"[dim]{msg}[/dim]")
            except AgentError as e:
                console.print(f"[red]Agent error: {e}[/red]")
                if verbose and e.agent_name:
                    console.print(f"[dim]Agent: {e.agent_name}[/dim]")
                raise typer.Exit(1) from None

    # Save the session
    session_path = orchestrator.save()
    session = orchestrator.session

    # Output based on format
    formatted = format_session(session, output_format)
    console.print(formatted)

    # Show where session was saved
    console.print(f"\n[dim]Session saved: {session_path}[/dim]")


RUN_EXAMPLES = """
[bold]Examples:[/bold]

  Run a session from config:
  [dim]$ focusgroup run session.toml[/dim]

  Preview what would run (dry run):
  [dim]$ focusgroup run session.toml --dry-run[/dim]

  Dry run with JSON output (for programmatic parsing):
  [dim]$ focusgroup run session.toml --dry-run --json[/dim]

  Save output to a directory:
  [dim]$ focusgroup run session.toml --output-dir ./results[/dim]

  Override output format:
  [dim]$ focusgroup run session.toml --format json[/dim]
"""


@app.command(epilog=RUN_EXAMPLES)
def run(
    config_file: Annotated[
        Path,
        typer.Argument(help="Path to session config TOML file"),
    ],
    output_dir: Annotated[
        Path | None,
        typer.Option("--output-dir", "-o", help="Directory for session output"),
    ] = None,
    dry_run: Annotated[
        bool,
        typer.Option("--dry-run", help="Show what would be done without executing"),
    ] = False,
    format: Annotated[
        str | None,
        typer.Option("--format", "-f", help="Output format override: json, markdown, or text"),
    ] = None,
    json_output: Annotated[
        bool,
        typer.Option("--json", help="Output as JSON (for --dry-run only)"),
    ] = False,
    timeout: Annotated[
        int | None,
        typer.Option("--timeout", help="Agent timeout in seconds (overrides config)"),
    ] = None,
) -> None:
    """Run a full feedback session from a config file."""
    if not config_file.exists():
        console.print(f"[red]Config file not found: {config_file}[/red]")
        raise typer.Exit(1)

    try:
        fg_config = load_config(config_file)
    except Exception as e:
        console.print(f"[red]Failed to load config: {e}[/red]")
        raise typer.Exit(1) from None

    # Override format if specified
    if format:
        fg_config.output.format = format  # type: ignore

    # Override timeout if specified
    if timeout is not None:
        fg_config.session.agent_timeout = timeout

    if dry_run:
        _show_session_plan(fg_config, json_output=json_output)
    else:
        if json_output:
            console.print("[yellow]Warning: --json is only used with --dry-run[/yellow]")
        asyncio.run(_run_impl(fg_config, output_dir))


def _show_session_plan(config: FocusgroupConfig, *, json_output: bool = False) -> None:
    """Show what would be done in a session."""
    import json

    if json_output:
        plan = {
            "tool": config.tool.command,
            "mode": config.session.mode.value,
            "moderator_enabled": config.session.moderator,
            "output_format": config.output.format,
            "exploration_enabled": config.session.exploration,
            "agents": [
                {
                    "name": agent.name,
                    "provider": agent.provider,
                    "model": agent.model,
                    "display_name": agent.display_name,
                }
                for agent in config.agents
            ],
            "questions": list(config.questions.rounds),
        }
        if config.session.moderator_agent:
            plan["moderator_agent"] = {
                "provider": config.session.moderator_agent.provider,
                "name": config.session.moderator_agent.name,
            }
        console.print(json.dumps(plan, indent=2))
        return

    console.print("\n[bold]Session Plan[/bold]")
    console.print(f"Tool: [cyan]{config.tool.command}[/cyan]")
    console.print(f"Mode: {config.session.mode.value}")
    console.print(f"Moderator: {'enabled' if config.session.moderator else 'disabled'}")
    console.print(f"Output format: {config.output.format}")

    console.print(f"\n[bold]Agents ({len(config.agents)}):[/bold]")
    for agent in config.agents:
        model_str = f"[{agent.model}]" if agent.model else ""
        console.print(f"  - {agent.display_name} {model_str}")

    console.print(f"\n[bold]Questions ({len(config.questions.rounds)}):[/bold]")
    for i, q in enumerate(config.questions.rounds):
        console.print(f"  {i + 1}. {q[:80]}{'...' if len(q) > 80 else ''}")


async def _run_impl(config: FocusgroupConfig, output_dir: Path | None) -> None:
    """Implementation of the run command."""
    # Create the tool wrapper
    cli_tool = create_cli_tool(config.tool.command)

    # Determine output directory
    if output_dir:
        output_dir.mkdir(parents=True, exist_ok=True)

    # Run the session
    orchestrator = SessionOrchestrator(config, cli_tool)

    if _plain_mode:
        console.print("Setting up session...")
        await orchestrator.setup()
        agent_count = len(orchestrator.agents)
        console.print(f"Session initialized with {agent_count} agents\n")

        round_count = len(config.questions.rounds)
        for round_num, result in enumerate(await _collect_results(orchestrator)):
            prompt_preview = result.prompt[:60]
            console.print(f"Round {round_num + 1}/{round_count}: {prompt_preview}...")
            for resp in result.responses:
                console.print(f"  {resp.agent_name}: {len(resp.content)} chars")
    else:
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console,
        ) as progress:
            setup_task = progress.add_task("Setting up session...", total=None)
            await orchestrator.setup()
            progress.remove_task(setup_task)

            agent_count = len(orchestrator.agents)
            console.print(f"[green]✓[/green] Session initialized with {agent_count} agents\n")

            round_count = len(config.questions.rounds)
            for round_num, result in enumerate(await _collect_results(orchestrator)):
                prompt_preview = result.prompt[:60]
                console.print(
                    f"[bold]Round {round_num + 1}/{round_count}:[/bold] {prompt_preview}..."
                )
                for resp in result.responses:
                    console.print(f"  [cyan]{resp.agent_name}[/cyan]: {len(resp.content)} chars")

    # Save the session
    session_path = orchestrator.save()
    session = orchestrator.session

    console.print("\n[green]✓[/green] Session complete")

    # Write output files if directory specified
    if output_dir:
        formatter = get_formatter(config.output.format)
        ext = "json" if config.output.format == "json" else "md"
        output_file = output_dir / f"{session.display_id}.{ext}"
        formatter.write(session, output_file)
        console.print(f"[green]✓[/green] Report saved: {output_file}")

    # Always show where session log was saved
    console.print(f"[dim]Session log: {session_path}[/dim]")

    # Print final synthesis if available
    if session.final_synthesis:
        console.print("\n[bold]Final Synthesis:[/bold]")
        console.print(session.final_synthesis)


async def _collect_results(orchestrator: SessionOrchestrator) -> list:
    """Collect all results from the orchestrator.

    Helper to iterate async generator into a list while
    allowing per-round output.
    """
    results = []
    async for result in orchestrator.run_session():
        results.append(result)
    return results


# --- Agents subcommand group ---

AGENTS_LIST_EXAMPLES = """
[bold]Examples:[/bold]

  List all presets:
  [dim]$ focusgroup agents list[/dim]

  Show detailed information:
  [dim]$ focusgroup agents list --verbose[/dim]

  Output as JSON for programmatic use:
  [dim]$ focusgroup agents list --json[/dim]
"""


@agents_app.command("list", epilog=AGENTS_LIST_EXAMPLES)
def agents_list(
    verbose: Annotated[
        bool,
        typer.Option("--verbose", "-v", help="Show detailed agent information"),
    ] = False,
    json_output: Annotated[
        bool,
        typer.Option("--json", help="Output as JSON for programmatic parsing"),
    ] = False,
) -> None:
    """List available agent presets."""
    import json

    presets = list_agent_presets()

    if json_output:
        # Output structured JSON for agent consumption
        data = []
        for name, path in presets:
            try:
                preset = load_agent_preset(path)
                data.append(
                    {
                        "name": name,
                        "provider": preset.provider_name,
                        "model": preset.model,
                        "display_name": preset.display_name,
                        "has_system_prompt": bool(preset.system_prompt),
                    }
                )
            except Exception as e:
                data.append(
                    {
                        "name": name,
                        "error": str(e),
                    }
                )
        console.print(json.dumps(data, indent=2))
        return

    if not presets:
        console.print("[dim]No agent presets found.[/dim]")
        console.print(f"[dim]Create presets in: {get_agents_dir()}[/dim]")
        return

    if verbose:
        for name, path in presets:
            console.print(f"\n[bold]{name}[/bold]")
            try:
                preset = load_agent_preset(path)
                console.print(f"  Provider: {preset.provider_name}")
                if preset.model:
                    console.print(f"  Model: {preset.model}")
                if preset.system_prompt:
                    preview = preset.system_prompt[:60]
                    console.print(f"  System: {preview}...")
            except Exception as e:
                console.print(f"  [red]Error loading: {e}[/red]")
    else:
        table = Table(title="Agent Presets")
        table.add_column("Name", style="cyan")
        table.add_column("Provider")
        table.add_column("Model")

        for name, path in presets:
            try:
                preset = load_agent_preset(path)
                table.add_row(name, preset.provider_name, preset.model or "-")
            except Exception:
                table.add_row(name, "[red]error[/red]", "")

        console.print(table)


AGENTS_INIT_EXAMPLES = """
[bold]Examples:[/bold]

  Create a new preset template:
  [dim]$ focusgroup agents init my-reviewer[/dim]

  Edit after creation:
  [dim]$ vim ~/.config/focusgroup/agents/my-reviewer.toml[/dim]
"""


AGENT_PRESET_TEMPLATE = '''# Agent preset: {name}
# Created by: focusgroup agents init
#
# This preset defines an agent configuration for focusgroup sessions.
# User presets override built-in ones with the same name.

[agent]
# Required: Provider CLI to use
# Options: "claude", "codex", or custom provider from providers.toml
provider = "claude"

# Optional: Display name shown in output (defaults to provider name)
name = "{display_name}"

# Optional: Specific model to use (provider default if not set)
# model = "opus"

# Optional: System prompt that shapes how the agent approaches feedback
# Uncomment and customize:
system_prompt = """You are reviewing a CLI tool designed for use by AI agents.

Focus your feedback on:
- Clarity of help output and error messages
- Ease of integration and automation
- Consistency of command patterns
- Discoverability of features

Provide specific, actionable suggestions."""

# Optional: Enable exploration mode (agents can run the tool)
# exploration = true

# Optional: Custom timeout in seconds (default: 120, exploration: 300)
# timeout = 180
'''


@agents_app.command("init", epilog=AGENTS_INIT_EXAMPLES)
def agents_init(
    name: Annotated[str, typer.Argument(help="Name for the new preset (alphanumeric and hyphens)")],
    force: Annotated[
        bool,
        typer.Option("--force", "-f", help="Overwrite existing preset"),
    ] = False,
) -> None:
    """Create a new agent preset template.

    Creates a TOML file in ~/.config/focusgroup/agents/ with documented
    fields for customization. Edit the file to configure your agent.

    Preset fields:
      provider      - Required. "claude", "codex", or custom provider
      name          - Display name in output
      model         - Specific model to use
      system_prompt - Shapes agent behavior/focus
      exploration   - Enable interactive tool testing
      timeout       - Custom timeout in seconds
    """
    import re

    # Validate name
    if not re.match(r"^[a-zA-Z][a-zA-Z0-9-]*$", name):
        console.print("[red]Invalid name. Use alphanumeric/hyphens, starting with a letter.[/red]")
        raise typer.Exit(1)

    agents_dir = get_agents_dir()
    preset_path = agents_dir / f"{name}.toml"

    if preset_path.exists() and not force:
        console.print(f"[red]Preset already exists: {preset_path}[/red]")
        console.print("[dim]Use --force to overwrite[/dim]")
        raise typer.Exit(1)

    # Generate display name from preset name
    display_name = name.replace("-", " ").title()

    content = AGENT_PRESET_TEMPLATE.format(name=name, display_name=display_name)
    preset_path.write_text(content)

    console.print(f"[green]✓[/green] Created preset: {preset_path}")
    console.print("\n[dim]Edit to customize, then use in sessions:[/dim]")
    console.print(f"  focusgroup ask 'question' -x 'tool --help' --agents {name}")


AGENTS_SHOW_EXAMPLES = """
[bold]Examples:[/bold]

  Show preset details:
  [dim]$ focusgroup agents show ux-expert[/dim]

  Show preset with custom system prompt:
  [dim]$ focusgroup agents show security-reviewer[/dim]

  Output as JSON for programmatic use:
  [dim]$ focusgroup agents show ux-expert --json[/dim]
"""


@agents_app.command("show", epilog=AGENTS_SHOW_EXAMPLES)
def agents_show(
    name: Annotated[str, typer.Argument(help="Agent preset name")],
    json_output: Annotated[
        bool,
        typer.Option("--json", help="Output as JSON for programmatic parsing"),
    ] = False,
) -> None:
    """Show details of an agent preset."""
    import json

    # Look in both user and bundled presets
    preset_path = get_preset_path(name)

    if not preset_path:
        if json_output:
            console.print(json.dumps({"error": f"Preset not found: {name}"}))
        else:
            console.print(f"[red]Preset not found: {name}[/red]")
            console.print("[dim]Available presets: focusgroup agents list[/dim]")
        raise typer.Exit(1)

    try:
        preset = load_agent_preset(preset_path)
    except Exception as e:
        if json_output:
            console.print(json.dumps({"error": f"Failed to load preset: {e}"}))
        else:
            console.print(f"[red]Failed to load preset: {e}[/red]")
        raise typer.Exit(1) from None

    if json_output:
        data = {
            "name": name,
            "provider": preset.provider_name,
            "model": preset.model,
            "display_name": preset.display_name,
            "system_prompt": preset.system_prompt,
            "exploration": preset.exploration,
        }
        console.print(json.dumps(data, indent=2))
        return

    console.print(f"\n[bold]Agent Preset: {name}[/bold]\n")
    console.print(f"Provider: [cyan]{preset.provider_name}[/cyan]")
    if preset.model:
        console.print(f"Model: {preset.model}")
    if preset.name:
        console.print(f"Display Name: {preset.name}")
    if preset.system_prompt:
        console.print(f"\nSystem Prompt:\n[dim]{preset.system_prompt}[/dim]")


# --- Logs subcommand group ---

LOGS_LIST_EXAMPLES = """
[bold]Examples:[/bold]

  Show recent sessions:
  [dim]$ focusgroup logs list[/dim]

  Show more sessions:
  [dim]$ focusgroup logs list --limit 25[/dim]

  Filter by tool:
  [dim]$ focusgroup logs list --tool mx[/dim]

  Filter by tag:
  [dim]$ focusgroup logs list --tag release-prep[/dim]

  Output as JSON for programmatic use:
  [dim]$ focusgroup logs list --json[/dim]
"""


@logs_app.command("list", epilog=LOGS_LIST_EXAMPLES)
def logs_list(
    limit: Annotated[
        int,
        typer.Option("--limit", "-n", help="Maximum number of logs to show"),
    ] = 10,
    tool: Annotated[
        str | None,
        typer.Option("--tool", "-t", help="Filter by tool name"),
    ] = None,
    tag: Annotated[
        str | None,
        typer.Option("--tag", help="Filter by tag"),
    ] = None,
    json_output: Annotated[
        bool,
        typer.Option("--json", help="Output as JSON for programmatic parsing"),
    ] = False,
) -> None:
    """List past session logs."""
    import json

    storage = get_default_storage()
    sessions = storage.list_sessions(limit=limit, tool_filter=tool, tag_filter=tag)

    if json_output:
        # Output structured JSON for agent consumption
        data = [
            {
                "id": s.display_id,
                "tool": s.tool,
                "mode": s.mode,
                "agent_count": s.agent_count,
                "rounds": len(s.rounds),
                "is_complete": s.is_complete,
                "created_at": s.created_at.isoformat(),
                "tags": s.tags,
            }
            for s in sessions
        ]
        console.print(json.dumps(data, indent=2))
        return

    if not sessions:
        console.print("[dim]No sessions found.[/dim]")
        if tool:
            console.print(f"[dim]Filtered by tool: {tool}[/dim]")
        return

    table = Table(title="Recent Sessions")
    table.add_column("ID", style="cyan")
    table.add_column("Tool")
    table.add_column("Mode")
    table.add_column("Agents", justify="right")
    table.add_column("Rounds", justify="right")
    table.add_column("Tags")
    table.add_column("Status")

    for session in sessions:
        status = "[green]✓[/green]" if session.is_complete else "[yellow]○[/yellow]"
        tags_str = ", ".join(session.tags) if session.tags else "-"
        table.add_row(
            session.display_id,
            session.tool,
            session.mode,
            str(session.agent_count),
            str(len(session.rounds)),
            tags_str,
            status,
        )

    console.print(table)


LOGS_SHOW_EXAMPLES = """
[bold]Examples:[/bold]

  Show session details:
  [dim]$ focusgroup logs show 20260105-abc123[/dim]

  Show the most recent session:
  [dim]$ focusgroup logs show latest[/dim]

  Show the 3rd most recent session:
  [dim]$ focusgroup logs show latest-2[/dim]

  Show as JSON (for programmatic use):
  [dim]$ focusgroup logs show 20260105-abc123 --json[/dim]

  Show as markdown:
  [dim]$ focusgroup logs show 20260105-abc123 --format markdown[/dim]
"""


def _resolve_session_id(session_id: str, storage: "SessionStorage") -> str:
    """Resolve special session ID shortcuts like 'latest' or 'latest-N'.

    Args:
        session_id: The session ID or shortcut to resolve
        storage: Session storage instance

    Returns:
        Resolved session display_id

    Raises:
        typer.Exit: If session cannot be found
    """
    # Check for 'latest' or 'latest-N' pattern
    if session_id == "latest":
        offset = 0
    elif session_id.startswith("latest-"):
        try:
            offset = int(session_id[7:])  # Parse the number after 'latest-'
        except ValueError:
            console.print(f"[red]Invalid latest offset: {session_id}[/red]")
            console.print("[dim]Use 'latest' or 'latest-N' where N is a number (0-indexed)[/dim]")
            raise typer.Exit(1) from None
    else:
        # Not a special shortcut, return as-is
        return session_id

    # Fetch enough sessions to satisfy the offset
    sessions = storage.list_sessions(limit=offset + 1)

    if not sessions:
        console.print("[red]No sessions found[/red]")
        raise typer.Exit(1)

    if offset >= len(sessions):
        console.print(
            f"[red]Only {len(sessions)} session(s) available, cannot access latest-{offset}[/red]"
        )
        raise typer.Exit(1)

    return sessions[offset].display_id


@logs_app.command("show", epilog=LOGS_SHOW_EXAMPLES)
def logs_show(
    session_id: Annotated[
        str,
        typer.Argument(help="Session ID, 'latest', or 'latest-N' for Nth most recent"),
    ],
    format: Annotated[
        str,
        typer.Option("--format", "-f", help="Output format: json, markdown, or text"),
    ] = "text",
    json_output: Annotated[
        bool,
        typer.Option("--json", help="Output as JSON (shortcut for --format json)"),
    ] = False,
) -> None:
    """Show details of a past session.

    Use 'latest' to show the most recent session, or 'latest-N' where N is
    a 0-indexed offset (e.g., 'latest-2' shows the 3rd most recent).
    """
    storage = get_default_storage()

    # Resolve special shortcuts like 'latest'
    resolved_id = _resolve_session_id(session_id, storage)

    try:
        session = storage.load(resolved_id)
    except FileNotFoundError:
        console.print(f"[red]Session not found: {resolved_id}[/red]")
        raise typer.Exit(1) from None
    except ValueError as e:
        console.print(f"[red]{e}[/red]")
        raise typer.Exit(1) from None

    # --json flag overrides --format
    output_format = "json" if json_output else format
    formatted = format_session(session, output_format)
    console.print(formatted)


LOGS_EXPORT_EXAMPLES = """
[bold]Examples:[/bold]

  Export to markdown (default):
  [dim]$ focusgroup logs export 20260105-abc123[/dim]

  Export the most recent session:
  [dim]$ focusgroup logs export latest[/dim]

  Export to JSON:
  [dim]$ focusgroup logs export 20260105-abc123 --format json[/dim]

  Export to specific file:
  [dim]$ focusgroup logs export 20260105-abc123 -o report.md[/dim]
"""


@logs_app.command("export", epilog=LOGS_EXPORT_EXAMPLES)
def logs_export(
    session_id: Annotated[
        str,
        typer.Argument(help="Session ID, 'latest', or 'latest-N' for Nth most recent"),
    ],
    output: Annotated[
        Path | None,
        typer.Option("--output", "-o", help="Output file path"),
    ] = None,
    format: Annotated[
        str,
        typer.Option("--format", "-f", help="Output format: json or markdown"),
    ] = "markdown",
) -> None:
    """Export a session to a file.

    Use 'latest' to export the most recent session.
    """
    storage = get_default_storage()

    # Resolve special shortcuts like 'latest'
    resolved_id = _resolve_session_id(session_id, storage)

    try:
        session = storage.load(resolved_id)
    except FileNotFoundError:
        console.print(f"[red]Session not found: {resolved_id}[/red]")
        raise typer.Exit(1) from None
    except ValueError as e:
        console.print(f"[red]{e}[/red]")
        raise typer.Exit(1) from None

    # Determine output path
    if output is None:
        ext = "json" if format == "json" else "md"
        output = Path(f"{session.display_id}.{ext}")

    # Get formatter and write
    try:
        formatter = get_formatter(format)
    except ValueError as e:
        console.print(f"[red]{e}[/red]")
        raise typer.Exit(1) from None

    formatter.write(session, output)
    console.print(f"[green]✓[/green] Exported to: {output}")


LOGS_DELETE_EXAMPLES = """
[bold]Examples:[/bold]

  Delete with confirmation:
  [dim]$ focusgroup logs delete 20260105-abc123[/dim]

  Delete the most recent session:
  [dim]$ focusgroup logs delete latest[/dim]

  Delete without confirmation:
  [dim]$ focusgroup logs delete 20260105-abc123 --force[/dim]
"""


@logs_app.command("delete", epilog=LOGS_DELETE_EXAMPLES)
def logs_delete(
    session_id: Annotated[
        str,
        typer.Argument(help="Session ID, 'latest', or 'latest-N' for Nth most recent"),
    ],
    force: Annotated[
        bool,
        typer.Option("--force", "-f", help="Delete without confirmation"),
    ] = False,
) -> None:
    """Delete a session log.

    Use 'latest' to delete the most recent session.
    """
    storage = get_default_storage()

    # Resolve special shortcuts like 'latest'
    resolved_id = _resolve_session_id(session_id, storage)

    # Verify session exists first
    try:
        session = storage.load(resolved_id)
    except FileNotFoundError:
        console.print(f"[red]Session not found: {resolved_id}[/red]")
        raise typer.Exit(1) from None

    if not force:
        confirm = typer.confirm(f"Delete session {session.display_id} ({session.tool})?")
        if not confirm:
            console.print("[dim]Cancelled.[/dim]")
            raise typer.Exit(0)

    if storage.delete(session.display_id):
        console.print(f"[green]✓[/green] Deleted: {session.display_id}")
    else:
        console.print("[red]Failed to delete session.[/red]")
        raise typer.Exit(1)


# --- Doctor command ---

DOCTOR_EXAMPLES = """
[bold]Examples:[/bold]

  Check setup:
  [dim]$ focusgroup doctor[/dim]

  Verbose output:
  [dim]$ focusgroup doctor --verbose[/dim]
"""


def _check_cli_installed(command: str) -> tuple[bool, str]:
    """Check if a CLI command is installed and get version.

    Returns:
        (is_installed, version_or_error)
    """
    try:
        result = subprocess.run(
            [command, "--version"],
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode == 0:
            version = result.stdout.strip() or result.stderr.strip()
            # Take first line of version output
            version = version.split("\n")[0].strip()
            return True, version
        return False, result.stderr.strip() or "Unknown error"
    except FileNotFoundError:
        return False, "Not installed"
    except subprocess.TimeoutExpired:
        return False, "Timed out checking version"
    except Exception as e:
        return False, str(e)


def _check_cli_auth(command: str) -> tuple[bool, str]:
    """Check if a CLI is properly authenticated.

    Returns:
        (is_authenticated, message)
    """
    # For claude, try a minimal prompt
    if command == "claude":
        try:
            result = subprocess.run(
                ["claude", "--version"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            # If version works, assume auth is configured
            # (actual auth is tested at runtime)
            if result.returncode == 0:
                return True, "CLI responds"
            return False, "CLI not responding"
        except Exception as e:
            return False, str(e)

    # For codex, check if it's configured
    elif command == "codex":
        try:
            result = subprocess.run(
                ["codex", "--version"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            if result.returncode == 0:
                return True, "CLI responds"
            return False, "CLI not responding"
        except Exception as e:
            return False, str(e)

    return False, "Unknown provider"


@app.command(epilog=DOCTOR_EXAMPLES)
def doctor(
    verbose: Annotated[
        bool,
        typer.Option("--verbose", "-v", help="Show detailed diagnostic info"),
    ] = False,
) -> None:
    """Check focusgroup setup and diagnose issues.

    Validates that provider CLIs are installed, credentials are configured,
    and config directories exist.
    """
    from focusgroup.config import get_agents_dir, get_default_config_dir

    all_ok = True
    console.print("\n[bold]Focusgroup Doctor[/bold]\n")

    # Check config directories
    console.print("[bold]Configuration:[/bold]")
    config_dir = get_default_config_dir()
    agents_dir = get_agents_dir()

    console.print(f"  Config dir: {config_dir}", end=" ")
    if config_dir.exists():
        console.print("[green]✓[/green]")
    else:
        console.print("[yellow]○ will be created on first use[/yellow]")

    console.print(f"  Agents dir: {agents_dir}", end=" ")
    if agents_dir.exists():
        preset_count = len(list(agents_dir.glob("*.toml")))
        if preset_count:
            console.print(f"[green]✓[/green] ({preset_count} presets)")
        else:
            console.print("[green]✓[/green] (empty)")
    else:
        console.print("[yellow]○ will be created on first use[/yellow]")

    # Check built-in providers
    console.print("\n[bold]Providers:[/bold]")

    builtin_providers = [
        ("claude", "Claude CLI"),
        ("codex", "Codex CLI"),
    ]

    for cmd, name in builtin_providers:
        console.print(f"  {name} ({cmd}):", end=" ")
        installed, version_msg = _check_cli_installed(cmd)

        if installed:
            console.print(f"[green]✓[/green] {version_msg}")

            if verbose:
                auth_ok, auth_msg = _check_cli_auth(cmd)
                console.print("    Auth: ", end="")
                if auth_ok:
                    console.print(f"[green]✓[/green] {auth_msg}")
                else:
                    console.print(f"[yellow]?[/yellow] {auth_msg}")
        else:
            console.print(f"[red]✗[/red] {version_msg}")
            all_ok = False

            # Provide actionable help
            if cmd == "claude":
                console.print("    [dim]Install: npm install -g @anthropic-ai/claude-code[/dim]")
            elif cmd == "codex":
                console.print("    [dim]Install: npm install -g @openai/codex[/dim]")

    # Check custom providers
    from focusgroup.agents.registry import get_custom_providers

    custom = get_custom_providers()
    if custom:
        console.print("\n[bold]Custom Providers:[/bold]")
        for name, info in custom.items():
            console.print(f"  {info.description} ({name}):", end=" ")
            installed, version_msg = _check_cli_installed(info.cli_command)
            if installed:
                console.print(f"[green]✓[/green] {version_msg}")
            else:
                console.print(f"[red]✗[/red] {version_msg}")

    # Check for session logs
    if verbose:
        console.print("\n[bold]Storage:[/bold]")
        storage = get_default_storage()
        try:
            sessions = storage.list_sessions(limit=5)
            console.print(f"  Session logs: [green]✓[/green] ({len(sessions)} recent)")
        except Exception as e:
            console.print(f"  Session logs: [yellow]?[/yellow] {e}")

    # Summary
    console.print()
    if all_ok:
        console.print("[green]✓ All checks passed[/green]")
    else:
        console.print("[yellow]Some providers are not installed[/yellow]")
        console.print("[dim]Install missing providers to use them in sessions.[/dim]")


# --- Demo command ---

DEMO_EXAMPLES = """
[bold]Examples:[/bold]

  Run a quick demo with defaults:
  [dim]$ focusgroup demo[/dim]

  Use a different provider:
  [dim]$ focusgroup demo --provider codex[/dim]

  Ask a custom question about focusgroup:
  [dim]$ focusgroup demo --question "What would make this tool easier for agents to use?"[/dim]
"""


@app.command(epilog=DEMO_EXAMPLES)
def demo(
    provider: Annotated[
        str,
        typer.Option("--provider", "-p", help="Agent provider: claude or codex"),
    ] = "claude",
    question: Annotated[
        str | None,
        typer.Option("--question", "-q", help="Custom question to ask about focusgroup"),
    ] = None,
    yes: Annotated[
        bool,
        typer.Option(
            "--yes",
            "-y",
            help="Skip cost confirmation prompts.",
        ),
    ] = False,
) -> None:
    """Run a self-referential demo of focusgroup.

    Runs focusgroup against itself - asks an agent to review focusgroup's
    own --help output. This is a quick way to see what focusgroup does
    and demonstrate dogfooding.
    """
    default_question = (
        "What's your first impression of this tool? "
        "Is the help output clear? What would you improve?"
    )
    final_question = question or default_question

    # Cost check for demo (single agent, simple query)
    from focusgroup.costs import estimate_cost, should_confirm

    estimate = estimate_cost(
        agent_count=1,
        provider=provider,
        exploration=False,
        synthesis=False,
    )

    if should_confirm(estimate) and not yes:
        console.print("\n[yellow]⚠ Cost Warning[/yellow]")
        console.print(f"Running {estimate.format_short()}")
        if not typer.confirm("Continue?", default=True):
            console.print("[dim]Cancelled.[/dim]")
            raise typer.Exit(0)

    console.print("\n[bold]Focusgroup Demo[/bold]")
    console.print("[dim]Asking an agent to review focusgroup's own --help...[/dim]\n")

    # Build the context by running focusgroup --help
    context = "focusgroup --help"

    asyncio.run(
        _ask_impl(
            tool="focusgroup",
            question=final_question,
            context=resolve_context(context),
            config_path=None,
            num_agents=1,
            output_format="text",
            provider_str=provider,
            explore=False,
            synthesize_with=None,
            timeout=None,
            tags=["demo"],
            verbose=False,
        )
    )


if __name__ == "__main__":
    app()

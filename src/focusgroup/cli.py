"""CLI interface for focusgroup."""

import asyncio
import subprocess
from pathlib import Path
from typing import Annotated

import typer
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.table import Table

from focusgroup import __version__
from focusgroup.config import (
    AgentConfig,
    AgentProvider,
    FocusgroupConfig,
    OutputConfig,
    QuestionsConfig,
    SessionConfig,
    ToolConfig,
    get_agents_dir,
    list_agent_presets,
    load_agent_preset,
    load_config,
)
from focusgroup.modes.orchestrator import SessionOrchestrator
from focusgroup.output import format_session, get_formatter
from focusgroup.storage.session_log import SessionStorage, get_default_storage
from focusgroup.tools.cli import create_cli_tool

MAIN_EPILOG = """
[bold]Providers:[/bold]

  [cyan]claude[/cyan] - Uses Claude CLI. Requires: claude CLI installed.
  [cyan]codex[/cyan]  - Uses Codex CLI. Requires: codex CLI installed.

  Both providers support exploration and synthesis modes.

[bold]Modes:[/bold]

  [cyan]--explore[/cyan] (-e)      Let agents run the tool interactively
  [cyan]--synthesize-with[/cyan]   Add a moderator to synthesize responses

[bold]Quick Start:[/bold]

  focusgroup ask "Is the help clear?" -x "mytool --help"
  focusgroup init                  # Create a config file
  focusgroup doctor                # Verify setup
"""

app = typer.Typer(
    name="focusgroup",
    help="Gather feedback from multiple LLM agents on tools designed for agent use.",
    no_args_is_help=True,
    epilog=MAIN_EPILOG,
)

agents_app = typer.Typer(help="Manage agent presets.")
logs_app = typer.Typer(help="View and manage session logs.")

app.add_typer(agents_app, name="agents")
app.add_typer(logs_app, name="logs")

console = Console()


# --- Init command ---

INIT_EXAMPLES = """
[bold]Examples:[/bold]

  Interactive setup (recommended for first use):
  [dim]$ focusgroup init[/dim]

  Specify output file:
  [dim]$ focusgroup init -o my-session.toml[/dim]

  Non-interactive with defaults:
  [dim]$ focusgroup init --tool mytool --quick[/dim]

  Quick setup with custom tool:
  [dim]$ focusgroup init --tool mx --provider claude --quick[/dim]
"""


def _generate_config_toml(
    tool: str,
    mode: str,
    provider: str,
    num_agents: int,
    questions: list[str],
    output_format: str,
    moderator: bool,
    exploration: bool,
) -> str:
    """Generate a TOML configuration file content."""
    lines = [
        "# =============================================================================",
        f"# Focusgroup Session Config - {tool}",
        "# =============================================================================",
        "#",
        "# Generated by: focusgroup init",
        "# Edit this file to customize your feedback session.",
        "#",
        "# Run with: focusgroup run <this-file>",
        "# =============================================================================",
        "",
        "[session]",
        f'name = "{tool}-feedback"',
        f'mode = "{mode}"',
    ]

    if exploration:
        lines.append("exploration = true          # Allow agents to run the tool")

    if moderator:
        lines.append("moderator = true            # Enable synthesis at the end")
        lines.append("")
        lines.append("[session.moderator_agent]")
        lines.append(f'provider = "{provider}"')
    else:
        lines.append("moderator = false")

    lines.extend(
        [
            "",
            "[tool]",
            f'command = "{tool}"',
            'help_args = ["--help"]     # Customize if your tool uses different args',
            "",
        ]
    )

    # Generate agents
    for i in range(num_agents):
        lines.append("[[agents]]")
        lines.append(f'provider = "{provider}"')
        if num_agents > 1:
            lines.append(f'name = "Agent-{i + 1}"')
        lines.append("")

    # Questions
    lines.append("[questions]")
    lines.append("rounds = [")
    for q in questions:
        # Escape quotes in the question
        escaped_q = q.replace('"', '\\"')
        lines.append(f'    "{escaped_q}",')
    lines.append("]")
    lines.append("")

    # Output
    lines.append("[output]")
    lines.append(f'format = "{output_format}"')
    lines.append("save_log = true")

    return "\n".join(lines) + "\n"


@app.command(epilog=INIT_EXAMPLES)
def init(
    output: Annotated[
        Path | None,
        typer.Option("--output", "-o", help="Output file path for config"),
    ] = None,
    tool: Annotated[
        str | None,
        typer.Option("--tool", "-t", help="Tool command to evaluate"),
    ] = None,
    provider: Annotated[
        str | None,
        typer.Option("--provider", "-p", help="Agent provider: claude or codex"),
    ] = None,
    quick: Annotated[
        bool,
        typer.Option("--quick", "-q", help="Use defaults, skip interactive prompts"),
    ] = False,
) -> None:
    """Initialize a new focusgroup session config file.

    Creates a TOML configuration file with prompts for tool name, questions,
    agent settings, and other options. Use --quick to skip prompts and use
    sensible defaults.
    """
    # Determine output path
    if output is None:
        default_name = f"{tool or 'session'}.toml" if tool else "focusgroup.toml"
        output = Path(default_name)

    # Check if file exists
    if output.exists() and not quick:
        overwrite = typer.confirm(f"File {output} already exists. Overwrite?")
        if not overwrite:
            console.print("[dim]Cancelled.[/dim]")
            raise typer.Exit(0)

    if quick:
        # Use defaults for quick mode
        final_tool = tool or "mytool"
        final_provider = provider or "claude"
        final_mode = "single"
        final_num_agents = 2
        final_questions = [
            "What's your first impression of this tool's interface?",
            "What improvements would make this tool easier for AI agents to use?",
        ]
        final_output_format = "text"
        final_moderator = False
        final_exploration = False
    else:
        # Interactive mode
        console.print("\n[bold]Focusgroup Session Setup[/bold]\n")

        # Tool
        final_tool = tool or typer.prompt(
            "Tool command to evaluate",
            default="mytool",
        )

        # Provider
        if provider:
            final_provider = provider
        else:
            console.print("\n[dim]Available providers: claude, codex[/dim]")
            final_provider = typer.prompt(
                "Agent provider",
                default="claude",
            )
            if final_provider not in ("claude", "codex"):
                console.print(
                    f"[yellow]Warning: '{final_provider}' is not a known provider[/yellow]"
                )

        # Mode
        console.print("\n[dim]Modes:[/dim]")
        console.print("  [cyan]single[/cyan]      - Each agent responds once, independently")
        console.print("  [cyan]discussion[/cyan]  - Agents see and respond to each other")
        console.print("  [cyan]structured[/cyan]  - Phases: explore, critique, suggest, synthesize")
        final_mode = typer.prompt(
            "Session mode",
            default="single",
        )

        # Number of agents
        final_num_agents = typer.prompt(
            "Number of agents",
            default=2,
            type=int,
        )

        # Questions
        console.print("\n[dim]Enter questions for the agents (empty line to finish):[/dim]")
        final_questions = []
        default_questions = [
            "What's your first impression of this tool's interface?",
            "What improvements would make this tool easier for AI agents to use?",
        ]

        for i, default_q in enumerate(default_questions):
            q = typer.prompt(f"Question {i + 1}", default=default_q)
            if q.strip():
                final_questions.append(q)

        # Allow more questions
        while True:
            q = typer.prompt(
                f"Question {len(final_questions) + 1} (Enter to skip)",
                default="",
            )
            if not q.strip():
                break
            final_questions.append(q)

        if not final_questions:
            final_questions = default_questions

        # Output format
        console.print("\n[dim]Output formats: text, markdown, json[/dim]")
        final_output_format = typer.prompt(
            "Output format",
            default="text",
        )

        # Moderator
        final_moderator = typer.confirm(
            "Enable moderator for synthesis?",
            default=False,
        )

        # Exploration
        final_exploration = typer.confirm(
            "Enable exploration (agents can run the tool)?",
            default=False,
        )

    # Generate config
    config_content = _generate_config_toml(
        tool=final_tool,
        mode=final_mode,
        provider=final_provider,
        num_agents=final_num_agents,
        questions=final_questions,
        output_format=final_output_format,
        moderator=final_moderator,
        exploration=final_exploration,
    )

    # Write file
    output.write_text(config_content)
    console.print(f"\n[green]✓[/green] Created config: {output}")
    console.print("\n[dim]Run your session with:[/dim]")
    console.print(f"  focusgroup run {output}")

    # Show next steps
    if not quick:
        console.print("\n[dim]Or try a quick check first:[/dim]")
        console.print(
            f'  focusgroup ask {final_tool} "Is the --help clear?" -x "{final_tool} --help"'
        )


def infer_tool_from_context(context: str) -> str:
    """Infer the tool name from a context string.

    Args:
        context: "@path/to/file" for file, "-" for stdin, or a command string

    Returns:
        Inferred tool name:
        - For commands: first token (e.g., "mx --help" -> "mx")
        - For files: filename stem (e.g., "@path/to/README.md" -> "README")
        - For stdin ("-"): "unknown"
        - Fallback: "unknown"
    """
    if not context or not context.strip():
        return "unknown"

    context = context.strip()

    if context == "-":
        # Stdin: can't infer tool name
        return "unknown"
    elif context.startswith("@"):
        # File context: use filename stem
        file_path = context[1:].strip()
        if file_path:
            return Path(file_path).stem or "unknown"
        return "unknown"
    else:
        # Command context: use first token
        tokens = context.split()
        if tokens:
            return tokens[0]
        return "unknown"


def resolve_context(context: str) -> str:
    """Resolve context from stdin, a file path, or shell command.

    Args:
        context: "-" for stdin, "@path/to/file" to read a file, or a shell command

    Returns:
        The stdin content, file contents, or command output

    Raises:
        typer.Exit: If file not found, command fails, or stdin read fails
    """
    import sys

    if context == "-":
        # Read from stdin
        try:
            return sys.stdin.read()
        except Exception as e:
            console.print(f"[red]Failed to read from stdin: {e}[/red]")
            raise typer.Exit(1) from None
    elif context.startswith("@"):
        # Read from file
        file_path = Path(context[1:]).expanduser()
        if not file_path.exists():
            console.print(f"[red]Context file not found: {file_path}[/red]")
            raise typer.Exit(1)
        try:
            return file_path.read_text()
        except Exception as e:
            console.print(f"[red]Failed to read context file: {e}[/red]")
            raise typer.Exit(1) from None
    else:
        # Run as shell command
        try:
            result = subprocess.run(
                context,
                shell=True,
                capture_output=True,
                text=True,
                timeout=30,
            )
            # Combine stdout and stderr (some tools output help to stderr)
            output = result.stdout
            if result.stderr and not output:
                output = result.stderr
            elif result.stderr:
                output = f"{output}\n{result.stderr}"

            if not output.strip():
                console.print("[yellow]Warning: Context command produced no output[/yellow]")

            return output
        except subprocess.TimeoutExpired:
            console.print("[red]Context command timed out after 30s[/red]")
            raise typer.Exit(1) from None
        except Exception as e:
            console.print(f"[red]Failed to run context command: {e}[/red]")
            raise typer.Exit(1) from None


def version_callback(value: bool) -> None:
    """Print version and exit."""
    if value:
        console.print(f"focusgroup {__version__}")
        raise typer.Exit()


@app.callback()
def main(
    version: Annotated[
        bool | None,
        typer.Option("--version", "-v", callback=version_callback, is_eager=True),
    ] = None,
) -> None:
    """Focusgroup: LLM agent feedback for tool developers."""
    pass


ASK_EXAMPLES = """
[bold]Examples:[/bold]

  Basic query (tool inferred from context):
  [dim]$ focusgroup ask "Is this help output clear?" -x "mx --help"[/dim]

  Query with file context (tool inferred as "README"):
  [dim]$ focusgroup ask "What's missing from these docs?" -x "@README.md"[/dim]

  Piped context from stdin (use --tool for labeling):
  [dim]$ cat API.md | focusgroup ask "Review this API" -x - --tool myapi[/dim]

  Explicit tool name override:
  [dim]$ focusgroup ask "Is this clear?" -x "mx --help" --tool memex[/dim]

  Exploration mode (agents can run the tool):
  [dim]$ focusgroup ask "Try common workflows" -x "mx --help" --explore[/dim]

  With synthesis from a moderator:
  [dim]$ focusgroup ask "Rate the UX" -x "mx --help" --synthesize-with claude[/dim]

  Use a different provider:
  [dim]$ focusgroup ask "Review this" -x "@docs.md" --provider codex[/dim]

  Combine multiple options:
  [dim]$ focusgroup ask "Full review" -x "mx --help" -e -s claude -n 5[/dim]
"""


@app.command(epilog=ASK_EXAMPLES)
def ask(
    question: Annotated[str, typer.Argument(help="Question to ask the agent panel")],
    context: Annotated[
        str,
        typer.Option(
            "--context",
            "-x",
            help="Context: command 'mytool --help', file '@README.md', or stdin '-'",
        ),
    ],
    tool: Annotated[
        str | None,
        typer.Option(
            "--tool",
            "-t",
            help="Tool name for session labeling (inferred from context if not provided)",
        ),
    ] = None,
    config: Annotated[
        Path | None,
        typer.Option("--config", "-c", help="Path to config file for agent settings"),
    ] = None,
    agents: Annotated[
        int,
        typer.Option("--agents", "-n", help="Number of agents to query"),
    ] = 3,
    output: Annotated[
        str,
        typer.Option("--output", "-o", help="Output format: json, markdown, or text"),
    ] = "text",
    provider: Annotated[
        str,
        typer.Option("--provider", "-p", help="Agent provider: claude or codex"),
    ] = "claude",
    explore: Annotated[
        bool,
        typer.Option("--explore", "-e", help="Enable exploration (agents can run tool)"),
    ] = False,
    synthesize_with: Annotated[
        str | None,
        typer.Option("--synthesize-with", "-s", help="Moderator agent: claude or codex"),
    ] = None,
    timeout: Annotated[
        int | None,
        typer.Option("--timeout", help="Agent timeout in seconds (default: 120, exploration: 300)"),
    ] = None,
) -> None:
    """Quick ad-hoc query to an agent panel about a tool.

    Provide context via --context: either a shell command to run (e.g., 'mytool --help')
    or a file path prefixed with @ (e.g., '@README.md').

    The tool name is inferred from context if not explicitly provided:
    - Command context: first token (e.g., 'mx --help' → tool='mx')
    - File context: filename stem (e.g., '@README.md' → tool='README')
    """
    # Resolve context upfront (file or command)
    resolved_context = resolve_context(context)

    # Infer tool name from context if not provided
    effective_tool = tool if tool else infer_tool_from_context(context)

    asyncio.run(
        _ask_impl(
            effective_tool,
            question,
            resolved_context,
            config,
            agents,
            output,
            provider,
            explore,
            synthesize_with,
            timeout,
        )
    )


def _parse_synthesize_with(synthesize_with: str | None) -> AgentConfig | None:
    """Parse --synthesize-with into an AgentConfig.

    Args:
        synthesize_with: String like 'codex' or 'claude'

    Returns:
        AgentConfig for the moderator, or None if not specified
    """
    if not synthesize_with:
        return None

    synthesize_with = synthesize_with.lower().strip()

    # Map string to provider
    provider_map = {
        "codex": AgentProvider.CODEX,
        "claude": AgentProvider.CLAUDE,
    }

    if synthesize_with not in provider_map:
        console.print(f"[red]Unknown synthesizer: {synthesize_with}[/red]")
        console.print("Valid options: claude, codex")
        raise typer.Exit(1)

    return AgentConfig(
        provider=provider_map[synthesize_with],
        name="Moderator",
    )


async def _ask_impl(
    tool: str,
    question: str,
    context: str,
    config_path: Path | None,
    num_agents: int,
    output_format: str,
    provider_str: str,
    explore: bool = False,
    synthesize_with: str | None = None,
    timeout: int | None = None,
) -> None:
    """Implementation of the ask command."""
    # Parse --synthesize-with into moderator config
    moderator_config = _parse_synthesize_with(synthesize_with)
    enable_moderator = moderator_config is not None

    # If config provided, load it but override with command-line args
    if config_path:
        try:
            fg_config = load_config(config_path)
            # Override questions
            fg_config.questions = QuestionsConfig(rounds=[question])
            fg_config.output.format = output_format  # type: ignore
            # Override moderator if --synthesize-with provided
            if moderator_config:
                fg_config.session.moderator = True
                fg_config.session.moderator_agent = moderator_config
            # Override timeout if provided
            if timeout is not None:
                fg_config.session.agent_timeout = timeout
        except Exception as e:
            console.print(f"[red]Failed to load config: {e}[/red]")
            raise typer.Exit(1) from None
    else:
        # Build a quick config
        try:
            prov = AgentProvider(provider_str.lower())
        except ValueError:
            console.print(f"[red]Unknown provider: {provider_str}[/red]")
            console.print("Valid options: claude, codex")
            raise typer.Exit(1) from None

        # Create N agents with different names
        agent_configs = [
            AgentConfig(
                provider=prov,
                name=f"Agent-{i + 1}",
            )
            for i in range(num_agents)
        ]

        fg_config = FocusgroupConfig(
            session=SessionConfig(
                name=f"Quick: {tool}",
                exploration=explore,
                moderator=enable_moderator,
                moderator_agent=moderator_config,
                agent_timeout=timeout,
            ),
            tool=ToolConfig(command=tool),
            agents=agent_configs,
            questions=QuestionsConfig(rounds=[question]),
            output=OutputConfig(format=output_format, save_log=True),  # type: ignore
        )

    # Create the tool wrapper (still used for exploration mode)
    cli_tool = create_cli_tool(tool)

    # Run the session with explicit context
    orchestrator = SessionOrchestrator(fg_config, cli_tool, context=context)

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console,
        transient=True,
    ) as progress:
        progress.add_task(f"Setting up with {len(fg_config.agents)} agents...", total=None)
        try:
            await orchestrator.setup()
        except Exception as e:
            console.print(f"[red]Setup failed: {e}[/red]")
            raise typer.Exit(1) from None

        progress.add_task(f"Asking about {tool}...", total=None)
        async for _result in orchestrator.run_session():
            # Results stream in, but we wait for all
            pass

    # Save the session
    session_path = orchestrator.save()
    session = orchestrator.session

    # Output based on format
    formatted = format_session(session, output_format)
    console.print(formatted)

    # Show where session was saved
    console.print(f"\n[dim]Session saved: {session_path}[/dim]")


RUN_EXAMPLES = """
[bold]Examples:[/bold]

  Run a session from config:
  [dim]$ focusgroup run session.toml[/dim]

  Preview what would run (dry run):
  [dim]$ focusgroup run session.toml --dry-run[/dim]

  Dry run with JSON output (for programmatic parsing):
  [dim]$ focusgroup run session.toml --dry-run --json[/dim]

  Save output to a directory:
  [dim]$ focusgroup run session.toml --output-dir ./results[/dim]

  Override output format:
  [dim]$ focusgroup run session.toml --format json[/dim]
"""


@app.command(epilog=RUN_EXAMPLES)
def run(
    config_file: Annotated[
        Path,
        typer.Argument(help="Path to session config TOML file"),
    ],
    output_dir: Annotated[
        Path | None,
        typer.Option("--output-dir", "-o", help="Directory for session output"),
    ] = None,
    dry_run: Annotated[
        bool,
        typer.Option("--dry-run", help="Show what would be done without executing"),
    ] = False,
    format: Annotated[
        str | None,
        typer.Option("--format", "-f", help="Output format override: json, markdown, or text"),
    ] = None,
    json_output: Annotated[
        bool,
        typer.Option("--json", help="Output as JSON (for --dry-run only)"),
    ] = False,
    timeout: Annotated[
        int | None,
        typer.Option("--timeout", help="Agent timeout in seconds (overrides config)"),
    ] = None,
) -> None:
    """Run a full feedback session from a config file."""
    if not config_file.exists():
        console.print(f"[red]Config file not found: {config_file}[/red]")
        raise typer.Exit(1)

    try:
        fg_config = load_config(config_file)
    except Exception as e:
        console.print(f"[red]Failed to load config: {e}[/red]")
        raise typer.Exit(1) from None

    # Override format if specified
    if format:
        fg_config.output.format = format  # type: ignore

    # Override timeout if specified
    if timeout is not None:
        fg_config.session.agent_timeout = timeout

    if dry_run:
        _show_session_plan(fg_config, json_output=json_output)
    else:
        if json_output:
            console.print("[yellow]Warning: --json is only used with --dry-run[/yellow]")
        asyncio.run(_run_impl(fg_config, output_dir))


def _show_session_plan(config: FocusgroupConfig, *, json_output: bool = False) -> None:
    """Show what would be done in a session."""
    import json

    if json_output:
        plan = {
            "tool": config.tool.command,
            "mode": config.session.mode.value,
            "moderator_enabled": config.session.moderator,
            "output_format": config.output.format,
            "exploration_enabled": config.session.exploration,
            "agents": [
                {
                    "name": agent.name,
                    "provider": agent.provider,
                    "model": agent.model,
                    "display_name": agent.display_name,
                }
                for agent in config.agents
            ],
            "questions": list(config.questions.rounds),
        }
        if config.session.moderator_agent:
            plan["moderator_agent"] = {
                "provider": config.session.moderator_agent.provider,
                "name": config.session.moderator_agent.name,
            }
        console.print(json.dumps(plan, indent=2))
        return

    console.print("\n[bold]Session Plan[/bold]")
    console.print(f"Tool: [cyan]{config.tool.command}[/cyan]")
    console.print(f"Mode: {config.session.mode.value}")
    console.print(f"Moderator: {'enabled' if config.session.moderator else 'disabled'}")
    console.print(f"Output format: {config.output.format}")

    console.print(f"\n[bold]Agents ({len(config.agents)}):[/bold]")
    for agent in config.agents:
        model_str = f"[{agent.model}]" if agent.model else ""
        console.print(f"  - {agent.display_name} {model_str}")

    console.print(f"\n[bold]Questions ({len(config.questions.rounds)}):[/bold]")
    for i, q in enumerate(config.questions.rounds):
        console.print(f"  {i + 1}. {q[:80]}{'...' if len(q) > 80 else ''}")


async def _run_impl(config: FocusgroupConfig, output_dir: Path | None) -> None:
    """Implementation of the run command."""
    # Create the tool wrapper
    cli_tool = create_cli_tool(config.tool.command)

    # Determine output directory
    if output_dir:
        output_dir.mkdir(parents=True, exist_ok=True)

    # Run the session
    orchestrator = SessionOrchestrator(config, cli_tool)

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console,
    ) as progress:
        setup_task = progress.add_task("Setting up session...", total=None)
        await orchestrator.setup()
        progress.remove_task(setup_task)

        agent_count = len(orchestrator.agents)
        console.print(f"[green]✓[/green] Session initialized with {agent_count} agents\n")

        round_count = len(config.questions.rounds)
        for round_num, result in enumerate(await _collect_results(orchestrator)):
            prompt_preview = result.prompt[:60]
            console.print(f"[bold]Round {round_num + 1}/{round_count}:[/bold] {prompt_preview}...")
            for resp in result.responses:
                console.print(f"  [cyan]{resp.agent_name}[/cyan]: {len(resp.content)} chars")

    # Save the session
    session_path = orchestrator.save()
    session = orchestrator.session

    console.print("\n[green]✓[/green] Session complete")

    # Write output files if directory specified
    if output_dir:
        formatter = get_formatter(config.output.format)
        ext = "json" if config.output.format == "json" else "md"
        output_file = output_dir / f"{session.display_id}.{ext}"
        formatter.write(session, output_file)
        console.print(f"[green]✓[/green] Report saved: {output_file}")

    # Always show where session log was saved
    console.print(f"[dim]Session log: {session_path}[/dim]")

    # Print final synthesis if available
    if session.final_synthesis:
        console.print("\n[bold]Final Synthesis:[/bold]")
        console.print(session.final_synthesis)


async def _collect_results(orchestrator: SessionOrchestrator) -> list:
    """Collect all results from the orchestrator.

    Helper to iterate async generator into a list while
    allowing per-round output.
    """
    results = []
    async for result in orchestrator.run_session():
        results.append(result)
    return results


# --- Agents subcommand group ---

AGENTS_LIST_EXAMPLES = """
[bold]Examples:[/bold]

  List all presets:
  [dim]$ focusgroup agents list[/dim]

  Show detailed information:
  [dim]$ focusgroup agents list --verbose[/dim]

  Output as JSON for programmatic use:
  [dim]$ focusgroup agents list --json[/dim]
"""


@agents_app.command("list", epilog=AGENTS_LIST_EXAMPLES)
def agents_list(
    verbose: Annotated[
        bool,
        typer.Option("--verbose", "-v", help="Show detailed agent information"),
    ] = False,
    json_output: Annotated[
        bool,
        typer.Option("--json", help="Output as JSON for programmatic parsing"),
    ] = False,
) -> None:
    """List available agent presets."""
    import json

    presets = list_agent_presets()

    if json_output:
        # Output structured JSON for agent consumption
        data = []
        for name, path in presets:
            try:
                preset = load_agent_preset(path)
                data.append(
                    {
                        "name": name,
                        "provider": preset.provider.value,
                        "model": preset.model,
                        "display_name": preset.display_name,
                        "has_system_prompt": bool(preset.system_prompt),
                    }
                )
            except Exception as e:
                data.append(
                    {
                        "name": name,
                        "error": str(e),
                    }
                )
        console.print(json.dumps(data, indent=2))
        return

    if not presets:
        console.print("[dim]No agent presets found.[/dim]")
        console.print(f"[dim]Create presets in: {get_agents_dir()}[/dim]")
        return

    if verbose:
        for name, path in presets:
            console.print(f"\n[bold]{name}[/bold]")
            try:
                preset = load_agent_preset(path)
                console.print(f"  Provider: {preset.provider.value}")
                if preset.model:
                    console.print(f"  Model: {preset.model}")
                if preset.system_prompt:
                    preview = preset.system_prompt[:60]
                    console.print(f"  System: {preview}...")
            except Exception as e:
                console.print(f"  [red]Error loading: {e}[/red]")
    else:
        table = Table(title="Agent Presets")
        table.add_column("Name", style="cyan")
        table.add_column("Provider")
        table.add_column("Model")

        for name, path in presets:
            try:
                preset = load_agent_preset(path)
                table.add_row(name, preset.provider.value, preset.model or "-")
            except Exception:
                table.add_row(name, "[red]error[/red]", "")

        console.print(table)


AGENTS_SHOW_EXAMPLES = """
[bold]Examples:[/bold]

  Show preset details:
  [dim]$ focusgroup agents show ux-expert[/dim]

  Show preset with custom system prompt:
  [dim]$ focusgroup agents show security-reviewer[/dim]

  Output as JSON for programmatic use:
  [dim]$ focusgroup agents show ux-expert --json[/dim]
"""


@agents_app.command("show", epilog=AGENTS_SHOW_EXAMPLES)
def agents_show(
    name: Annotated[str, typer.Argument(help="Agent preset name")],
    json_output: Annotated[
        bool,
        typer.Option("--json", help="Output as JSON for programmatic parsing"),
    ] = False,
) -> None:
    """Show details of an agent preset."""
    import json

    agents_dir = get_agents_dir()
    preset_path = agents_dir / f"{name}.toml"

    if not preset_path.exists():
        if json_output:
            console.print(json.dumps({"error": f"Preset not found: {name}"}))
        else:
            console.print(f"[red]Preset not found: {name}[/red]")
            console.print(f"[dim]Looked in: {preset_path}[/dim]")
        raise typer.Exit(1)

    try:
        preset = load_agent_preset(preset_path)
    except Exception as e:
        if json_output:
            console.print(json.dumps({"error": f"Failed to load preset: {e}"}))
        else:
            console.print(f"[red]Failed to load preset: {e}[/red]")
        raise typer.Exit(1) from None

    if json_output:
        data = {
            "name": name,
            "provider": preset.provider.value,
            "model": preset.model,
            "display_name": preset.display_name,
            "system_prompt": preset.system_prompt,
            "exploration": preset.exploration,
        }
        console.print(json.dumps(data, indent=2))
        return

    console.print(f"\n[bold]Agent Preset: {name}[/bold]\n")
    console.print(f"Provider: [cyan]{preset.provider.value}[/cyan]")
    if preset.model:
        console.print(f"Model: {preset.model}")
    if preset.name:
        console.print(f"Display Name: {preset.name}")
    if preset.system_prompt:
        console.print(f"\nSystem Prompt:\n[dim]{preset.system_prompt}[/dim]")


# --- Logs subcommand group ---

LOGS_LIST_EXAMPLES = """
[bold]Examples:[/bold]

  Show recent sessions:
  [dim]$ focusgroup logs list[/dim]

  Show more sessions:
  [dim]$ focusgroup logs list --limit 25[/dim]

  Filter by tool:
  [dim]$ focusgroup logs list --tool mx[/dim]

  Output as JSON for programmatic use:
  [dim]$ focusgroup logs list --json[/dim]
"""


@logs_app.command("list", epilog=LOGS_LIST_EXAMPLES)
def logs_list(
    limit: Annotated[
        int,
        typer.Option("--limit", "-n", help="Maximum number of logs to show"),
    ] = 10,
    tool: Annotated[
        str | None,
        typer.Option("--tool", "-t", help="Filter by tool name"),
    ] = None,
    json_output: Annotated[
        bool,
        typer.Option("--json", help="Output as JSON for programmatic parsing"),
    ] = False,
) -> None:
    """List past session logs."""
    import json

    storage = get_default_storage()
    sessions = storage.list_sessions(limit=limit, tool_filter=tool)

    if json_output:
        # Output structured JSON for agent consumption
        data = [
            {
                "id": s.display_id,
                "tool": s.tool,
                "mode": s.mode,
                "agent_count": s.agent_count,
                "rounds": len(s.rounds),
                "is_complete": s.is_complete,
                "created_at": s.created_at.isoformat(),
            }
            for s in sessions
        ]
        console.print(json.dumps(data, indent=2))
        return

    if not sessions:
        console.print("[dim]No sessions found.[/dim]")
        if tool:
            console.print(f"[dim]Filtered by tool: {tool}[/dim]")
        return

    table = Table(title="Recent Sessions")
    table.add_column("ID", style="cyan")
    table.add_column("Tool")
    table.add_column("Mode")
    table.add_column("Agents", justify="right")
    table.add_column("Rounds", justify="right")
    table.add_column("Status")

    for session in sessions:
        status = "[green]✓[/green]" if session.is_complete else "[yellow]○[/yellow]"
        table.add_row(
            session.display_id,
            session.tool,
            session.mode,
            str(session.agent_count),
            str(len(session.rounds)),
            status,
        )

    console.print(table)


LOGS_SHOW_EXAMPLES = """
[bold]Examples:[/bold]

  Show session details:
  [dim]$ focusgroup logs show 20260105-abc123[/dim]

  Show the most recent session:
  [dim]$ focusgroup logs show latest[/dim]

  Show the 3rd most recent session:
  [dim]$ focusgroup logs show latest-2[/dim]

  Show as JSON (for programmatic use):
  [dim]$ focusgroup logs show 20260105-abc123 --json[/dim]

  Show as markdown:
  [dim]$ focusgroup logs show 20260105-abc123 --format markdown[/dim]
"""


def _resolve_session_id(session_id: str, storage: "SessionStorage") -> str:
    """Resolve special session ID shortcuts like 'latest' or 'latest-N'.

    Args:
        session_id: The session ID or shortcut to resolve
        storage: Session storage instance

    Returns:
        Resolved session display_id

    Raises:
        typer.Exit: If session cannot be found
    """
    # Check for 'latest' or 'latest-N' pattern
    if session_id == "latest":
        offset = 0
    elif session_id.startswith("latest-"):
        try:
            offset = int(session_id[7:])  # Parse the number after 'latest-'
        except ValueError:
            console.print(f"[red]Invalid latest offset: {session_id}[/red]")
            console.print("[dim]Use 'latest' or 'latest-N' where N is a number (0-indexed)[/dim]")
            raise typer.Exit(1) from None
    else:
        # Not a special shortcut, return as-is
        return session_id

    # Fetch enough sessions to satisfy the offset
    sessions = storage.list_sessions(limit=offset + 1)

    if not sessions:
        console.print("[red]No sessions found[/red]")
        raise typer.Exit(1)

    if offset >= len(sessions):
        console.print(
            f"[red]Only {len(sessions)} session(s) available, cannot access latest-{offset}[/red]"
        )
        raise typer.Exit(1)

    return sessions[offset].display_id


@logs_app.command("show", epilog=LOGS_SHOW_EXAMPLES)
def logs_show(
    session_id: Annotated[
        str,
        typer.Argument(help="Session ID, 'latest', or 'latest-N' for Nth most recent"),
    ],
    format: Annotated[
        str,
        typer.Option("--format", "-f", help="Output format: json, markdown, or text"),
    ] = "text",
    json_output: Annotated[
        bool,
        typer.Option("--json", help="Output as JSON (shortcut for --format json)"),
    ] = False,
) -> None:
    """Show details of a past session.

    Use 'latest' to show the most recent session, or 'latest-N' where N is
    a 0-indexed offset (e.g., 'latest-2' shows the 3rd most recent).
    """
    storage = get_default_storage()

    # Resolve special shortcuts like 'latest'
    resolved_id = _resolve_session_id(session_id, storage)

    try:
        session = storage.load(resolved_id)
    except FileNotFoundError:
        console.print(f"[red]Session not found: {resolved_id}[/red]")
        raise typer.Exit(1) from None
    except ValueError as e:
        console.print(f"[red]{e}[/red]")
        raise typer.Exit(1) from None

    # --json flag overrides --format
    output_format = "json" if json_output else format
    formatted = format_session(session, output_format)
    console.print(formatted)


LOGS_EXPORT_EXAMPLES = """
[bold]Examples:[/bold]

  Export to markdown (default):
  [dim]$ focusgroup logs export 20260105-abc123[/dim]

  Export the most recent session:
  [dim]$ focusgroup logs export latest[/dim]

  Export to JSON:
  [dim]$ focusgroup logs export 20260105-abc123 --format json[/dim]

  Export to specific file:
  [dim]$ focusgroup logs export 20260105-abc123 -o report.md[/dim]
"""


@logs_app.command("export", epilog=LOGS_EXPORT_EXAMPLES)
def logs_export(
    session_id: Annotated[
        str,
        typer.Argument(help="Session ID, 'latest', or 'latest-N' for Nth most recent"),
    ],
    output: Annotated[
        Path | None,
        typer.Option("--output", "-o", help="Output file path"),
    ] = None,
    format: Annotated[
        str,
        typer.Option("--format", "-f", help="Output format: json or markdown"),
    ] = "markdown",
) -> None:
    """Export a session to a file.

    Use 'latest' to export the most recent session.
    """
    storage = get_default_storage()

    # Resolve special shortcuts like 'latest'
    resolved_id = _resolve_session_id(session_id, storage)

    try:
        session = storage.load(resolved_id)
    except FileNotFoundError:
        console.print(f"[red]Session not found: {resolved_id}[/red]")
        raise typer.Exit(1) from None
    except ValueError as e:
        console.print(f"[red]{e}[/red]")
        raise typer.Exit(1) from None

    # Determine output path
    if output is None:
        ext = "json" if format == "json" else "md"
        output = Path(f"{session.display_id}.{ext}")

    # Get formatter and write
    try:
        formatter = get_formatter(format)
    except ValueError as e:
        console.print(f"[red]{e}[/red]")
        raise typer.Exit(1) from None

    formatter.write(session, output)
    console.print(f"[green]✓[/green] Exported to: {output}")


LOGS_DELETE_EXAMPLES = """
[bold]Examples:[/bold]

  Delete with confirmation:
  [dim]$ focusgroup logs delete 20260105-abc123[/dim]

  Delete the most recent session:
  [dim]$ focusgroup logs delete latest[/dim]

  Delete without confirmation:
  [dim]$ focusgroup logs delete 20260105-abc123 --force[/dim]
"""


@logs_app.command("delete", epilog=LOGS_DELETE_EXAMPLES)
def logs_delete(
    session_id: Annotated[
        str,
        typer.Argument(help="Session ID, 'latest', or 'latest-N' for Nth most recent"),
    ],
    force: Annotated[
        bool,
        typer.Option("--force", "-f", help="Delete without confirmation"),
    ] = False,
) -> None:
    """Delete a session log.

    Use 'latest' to delete the most recent session.
    """
    storage = get_default_storage()

    # Resolve special shortcuts like 'latest'
    resolved_id = _resolve_session_id(session_id, storage)

    # Verify session exists first
    try:
        session = storage.load(resolved_id)
    except FileNotFoundError:
        console.print(f"[red]Session not found: {resolved_id}[/red]")
        raise typer.Exit(1) from None

    if not force:
        confirm = typer.confirm(f"Delete session {session.display_id} ({session.tool})?")
        if not confirm:
            console.print("[dim]Cancelled.[/dim]")
            raise typer.Exit(0)

    if storage.delete(session.display_id):
        console.print(f"[green]✓[/green] Deleted: {session.display_id}")
    else:
        console.print("[red]Failed to delete session.[/red]")
        raise typer.Exit(1)


# --- Doctor command ---

DOCTOR_EXAMPLES = """
[bold]Examples:[/bold]

  Check setup:
  [dim]$ focusgroup doctor[/dim]

  Verbose output:
  [dim]$ focusgroup doctor --verbose[/dim]
"""


def _check_cli_installed(command: str) -> tuple[bool, str]:
    """Check if a CLI command is installed and get version.

    Returns:
        (is_installed, version_or_error)
    """
    try:
        result = subprocess.run(
            [command, "--version"],
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode == 0:
            version = result.stdout.strip() or result.stderr.strip()
            # Take first line of version output
            version = version.split("\n")[0].strip()
            return True, version
        return False, result.stderr.strip() or "Unknown error"
    except FileNotFoundError:
        return False, "Not installed"
    except subprocess.TimeoutExpired:
        return False, "Timed out checking version"
    except Exception as e:
        return False, str(e)


def _check_cli_auth(command: str) -> tuple[bool, str]:
    """Check if a CLI is properly authenticated.

    Returns:
        (is_authenticated, message)
    """
    # For claude, try a minimal prompt
    if command == "claude":
        try:
            result = subprocess.run(
                ["claude", "--version"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            # If version works, assume auth is configured
            # (actual auth is tested at runtime)
            if result.returncode == 0:
                return True, "CLI responds"
            return False, "CLI not responding"
        except Exception as e:
            return False, str(e)

    # For codex, check if it's configured
    elif command == "codex":
        try:
            result = subprocess.run(
                ["codex", "--version"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            if result.returncode == 0:
                return True, "CLI responds"
            return False, "CLI not responding"
        except Exception as e:
            return False, str(e)

    return False, "Unknown provider"


@app.command(epilog=DOCTOR_EXAMPLES)
def doctor(
    verbose: Annotated[
        bool,
        typer.Option("--verbose", "-v", help="Show detailed diagnostic info"),
    ] = False,
) -> None:
    """Check focusgroup setup and diagnose issues.

    Validates that provider CLIs are installed, credentials are configured,
    and config directories exist.
    """
    from focusgroup.config import get_agents_dir, get_default_config_dir

    all_ok = True
    console.print("\n[bold]Focusgroup Doctor[/bold]\n")

    # Check config directories
    console.print("[bold]Configuration:[/bold]")
    config_dir = get_default_config_dir()
    agents_dir = get_agents_dir()

    console.print(f"  Config dir: {config_dir}", end=" ")
    if config_dir.exists():
        console.print("[green]✓[/green]")
    else:
        console.print("[yellow]○ will be created on first use[/yellow]")

    console.print(f"  Agents dir: {agents_dir}", end=" ")
    if agents_dir.exists():
        preset_count = len(list(agents_dir.glob("*.toml")))
        if preset_count:
            console.print(f"[green]✓[/green] ({preset_count} presets)")
        else:
            console.print("[green]✓[/green] (empty)")
    else:
        console.print("[yellow]○ will be created on first use[/yellow]")

    # Check providers
    console.print("\n[bold]Providers:[/bold]")

    providers = [
        ("claude", "Claude CLI"),
        ("codex", "Codex CLI"),
    ]

    for cmd, name in providers:
        console.print(f"  {name} ({cmd}):", end=" ")
        installed, version_msg = _check_cli_installed(cmd)

        if installed:
            console.print(f"[green]✓[/green] {version_msg}")

            if verbose:
                auth_ok, auth_msg = _check_cli_auth(cmd)
                console.print("    Auth: ", end="")
                if auth_ok:
                    console.print(f"[green]✓[/green] {auth_msg}")
                else:
                    console.print(f"[yellow]?[/yellow] {auth_msg}")
        else:
            console.print(f"[red]✗[/red] {version_msg}")
            all_ok = False

            # Provide actionable help
            if cmd == "claude":
                console.print("    [dim]Install: npm install -g @anthropic-ai/claude-code[/dim]")
            elif cmd == "codex":
                console.print("    [dim]Install: npm install -g @openai/codex[/dim]")

    # Check for session logs
    if verbose:
        console.print("\n[bold]Storage:[/bold]")
        storage = get_default_storage()
        try:
            sessions = storage.list_sessions(limit=5)
            console.print(f"  Session logs: [green]✓[/green] ({len(sessions)} recent)")
        except Exception as e:
            console.print(f"  Session logs: [yellow]?[/yellow] {e}")

    # Summary
    console.print()
    if all_ok:
        console.print("[green]✓ All checks passed[/green]")
    else:
        console.print("[yellow]Some providers are not installed[/yellow]")
        console.print("[dim]Install missing providers to use them in sessions.[/dim]")


if __name__ == "__main__":
    app()
